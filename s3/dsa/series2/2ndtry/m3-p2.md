## Part 3: Binary Search Trees (BST)

A **Binary Search Tree** is a special type of binary tree with a specific ordering property that makes operations like searching, insertion, and deletion very efficient.

### The BST Property (Crucial!)

For any given node `N` in a BST:
1.  All values in the **left subtree** of `N` are **less than** the value of `N`.
2.  All values in the **right subtree** of `N` are **greater than or equal to** the value of `N`.
3.  Both the left and right subtrees must also be binary search trees.

*   [Visual Example of the BST Property](https://www.google.com/search?tbm=isch&q=binary+search+tree+property)

This property is the key to everything that follows. It's what allows for fast searching.

### Operations on Binary Search Trees

#### 1. Searching in a BST

Because of the BST property, we don't need to check every node. We can eliminate half of the remaining tree at each step.

**Logic:**
1.  Start at the root.
2.  Compare the value you're searching for (`VAL`) with the current node's value.
    *   If they match, you've found it!
    *   If `VAL` is **less than** the node's value, you only need to search in the **left subtree**.
    *   If `VAL` is **greater than** the node's value, you only need to search in the **right subtree**.
3.  Repeat this process until you find the value or reach an empty spot (null), which means the value isn't in the tree.

*   [Visual Example of Searching in a BST](https://www.google.com/search?tbm=isch&q=searching+in+a+binary+search+tree+animation)

**Algorithm (Pseudocode):**
```
searchElement(TREE, VAL)
  Step 1: IF TREE is NULL OR TREE -> DATA == VAL
             Return TREE
          ELSE
             IF VAL < TREE -> DATA
                Return searchElement(TREE -> LEFT, VAL)
             ELSE
                Return searchElement(TREE -> RIGHT, VAL)
             [END OF IF]
          [END OF IF]
Step 2: END
```

#### 2. Insertion into a BST

To insert a new value, you first search for where it *should* be, and then you add it there.

**Logic:**
1.  Start at the root.
2.  Compare the new value (`VAL`) with the current node's value.
3.  If `VAL` is less than the current node, move to the left child.
4.  If `VAL` is greater than or equal to the current node, move to the right child.
5.  Repeat until you find an empty spot (a null child). Insert the new node there.

*   [Visual Example of Insertion into a BST](https://www.google.com/search?tbm=isch&q=insertion+into+binary+search+tree+steps)

**Algorithm (Pseudocode):**
```
Insert(TREE, VAL)
  Step 1: IF TREE is NULL
             Allocate memory for a new node
             Set new node -> DATA = VAL
             Set new node -> LEFT = NULL
             Set new node -> RIGHT = NULL
             Return the new node
          ELSE
             IF VAL < TREE -> DATA
                TREE -> LEFT = Insert(TREE -> LEFT, VAL)
             ELSE
                TREE -> RIGHT = Insert(TREE -> RIGHT, VAL)
             [END OF IF]
             Return TREE
          [END OF IF]
Step 2: END
```

**Example Application: Constructing a BST (Common Exam Question!)**

As your teacher mentioned, this is a likely application-style question. Let's construct a BST from the values in sample question paper `3001BER24P304`: `25, 55, 71, 10, 9, 11, 6, 67, 45, 23`.

*   **Insert 25:** The tree is empty. 25 becomes the root.
*   **Insert 55:** 55 > 25, so it goes to the right of 25.
*   **Insert 71:** 71 > 25 (go right); 71 > 55 (go right).
*   **Insert 10:** 10 < 25, so it goes to the left of 25.
*   **Insert 9:** 9 < 25 (go left); 9 < 10 (go left).
*   **Insert 11:** 11 < 25 (go left); 11 > 10 (go right).
*   ...and so on.

You would draw the tree at each step. The final tree would look like this:

*   [Final Constructed BST from the example](https://www.google.com/search?tbm=isch&q=binary+search+tree+25+55+71+10+9+11+6+67+45+23)

#### 3. Deletion from a BST

Deletion is the most complex operation because you must maintain the BST property after removing a node. There are three cases.

**Case 1: Deleting a Leaf Node (No Children)**
This is the easiest case. Simply remove the node.
*   [Visual Example of Deleting a Leaf Node](https://www.google.com/search?tbm=isch&q=bst+delete+leaf+node)

**Case 2: Deleting a Node with One Child**
Remove the node and replace it with its single child. The child's subtree just moves up one level.
*   [Visual Example of Deleting a Node with One Child](https://www.google.com/search?tbm=isch&q=bst+delete+node+one+child)

**Case 3: Deleting a Node with Two Children**
This is the tricky one. You cannot simply remove the node as it would leave two disconnected subtrees.
**The Rule:** Replace the node to be deleted with either:
*   Its **in-order successor**: The smallest value in its right subtree.
*   Its **in-order predecessor**: The largest value in its left subtree.

Then, delete the successor/predecessor from its original position (which will be a Case 1 or Case 2 deletion).

**Example (Deleting a node with two children):**
Imagine you need to delete node **55** from the tree we built earlier.
1.  **Find the in-order successor:** Go to the right child (71), then go as far left as possible. The successor is **67**.
2.  **Replace:** Copy the value 67 into the node that currently holds 55.
3.  **Delete:** Now delete the original node 67 (which is a Case 1 or Case 2 deletion).

*   [Visual Example of Deleting a Node with Two Children](https://www.google.com/search?tbm=isch&q=bst+delete+node+two+children+inorder+successor)

**Comprehensive Deletion Algorithm (Pseudocode):**
```
Delete(TREE, VAL)
  Step 1: IF TREE is NULL, return TREE
  
  Step 2: IF VAL < TREE -> DATA
             TREE -> LEFT = Delete(TREE -> LEFT, VAL)
          ELSE IF VAL > TREE -> DATA
             TREE -> RIGHT = Delete(TREE -> RIGHT, VAL)
          ELSE  // Found the node to delete
             // Case 1: No child or one child
             IF TREE -> LEFT is NULL
                TEMP = TREE -> RIGHT
                Free TREE
                Return TEMP
             ELSE IF TREE -> RIGHT is NULL
                TEMP = TREE -> LEFT
                Free TREE
                Return TEMP
             
             // Case 3: Two children
             TEMP = findSmallestNode(TREE -> RIGHT) // In-order successor
             TREE -> DATA = TEMP -> DATA
             TREE -> RIGHT = Delete(TREE -> RIGHT, TEMP -> DATA)
          [END OF IF]
  Step 3: Return TREE
```

This completes the core topics for Module 3. Focus on understanding the *logic* behind the algorithms and practice drawing the trees for insertion and deletion questions.
